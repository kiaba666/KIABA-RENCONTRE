"""
Django settings for kiaba project.

Generated by 'django-admin startproject' using Django 5.1.2.

This settings module is configured for:
- PostgreSQL (from environment variables)
- Redis cache
- Celery (broker + backend via Redis)
- django-allauth (limited signup will be enforced via a custom adapter later)
- Static/Media (FileSystem by default; S3 via env)
- i18n (fr default, en optional)
- Security headers (baseline)
"""

from pathlib import Path
import os
import sys

try:
    import environ  # type: ignore
except Exception:
    environ = None

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent


if environ is not None:
    env = environ.Env(
        DEBUG=(bool, False),
        SECRET_KEY=(str, "change-me"),
        ALLOWED_HOSTS=(str, "localhost,127.0.0.1"),
        LANGUAGE_CODE=(str, "fr"),
        TIME_ZONE=(str, "Africa/Abidjan"),
        # Database
        DB_ENGINE=(str, "postgres"),  # 'postgres' or 'sqlite'
        POSTGRES_DB=(str, "kiaba"),
        POSTGRES_USER=(str, "kiaba"),
        POSTGRES_PASSWORD=(str, "kiaba"),
        POSTGRES_HOST=(str, "localhost"),
        POSTGRES_PORT=(int, 5432),
        # Redis
        REDIS_URL=(str, "redis://localhost:6379/1"),
        # Static/Media
        DEFAULT_FILE_STORAGE=(str, "django.core.files.storage.FileSystemStorage"),
        STATIC_URL=(str, "/static/"),
        STATIC_ROOT=(str, "staticfiles"),
        MEDIA_URL=(str, "/media/"),
        MEDIA_ROOT=(str, "media"),
        # Email
        EMAIL_BACKEND=(str, "django.core.mail.backends.console.EmailBackend"),
        EMAIL_HOST=(str, "localhost"),
        EMAIL_PORT=(int, 25),
        EMAIL_USE_SSL=(bool, False),
        EMAIL_USE_TLS=(bool, False),
        EMAIL_HOST_USER=(str, ""),
        EMAIL_HOST_PASSWORD=(str, ""),
        DEFAULT_FROM_EMAIL=(str, "KIABA <no-reply@example.com>"),
        SERVER_EMAIL=(str, "KIABA Errors <errors@example.com>"),
    )
    environ.Env.read_env(os.path.join(Path(__file__).resolve().parent.parent, ".env"))
else:

    class _DummyEnv:
        def __init__(self, **schema):
            self.schema = schema

        def __call__(self, key, default=None):
            if default is None and key in self.schema:
                default = self.schema[key][1]
            value = os.environ.get(key, default)
            return value

        def int(self, key, default=0):
            try:
                return int(os.environ.get(key, default))
            except Exception:
                return default

    env = _DummyEnv(
        DEBUG=(bool, False),
        SECRET_KEY=(str, "change-me"),
        ALLOWED_HOSTS=(str, "localhost,127.0.0.1"),
        LANGUAGE_CODE=(str, "fr"),
        TIME_ZONE=(str, "Africa/Abidjan"),
        DB_ENGINE=(str, "postgres"),
        POSTGRES_DB=(str, "kiaba"),
        POSTGRES_USER=(str, "kiaba"),
        POSTGRES_PASSWORD=(str, "kiaba"),
        POSTGRES_HOST=(str, "localhost"),
        POSTGRES_PORT=(int, 5432),
        REDIS_URL=(str, "redis://localhost:6379/1"),
        DEFAULT_FILE_STORAGE=(str, "django.core.files.storage.FileSystemStorage"),
        STATIC_URL=(str, "/static/"),
        STATIC_ROOT=(str, "staticfiles"),
        MEDIA_URL=(str, "/media/"),
        MEDIA_ROOT=(str, "media"),
        EMAIL_BACKEND=(str, "django.core.mail.backends.console.EmailBackend"),
        EMAIL_HOST=(str, "localhost"),
        EMAIL_PORT=(int, 25),
        EMAIL_USE_SSL=(bool, False),
        EMAIL_USE_TLS=(bool, False),
        EMAIL_HOST_USER=(str, ""),
        EMAIL_HOST_PASSWORD=(str, ""),
        DEFAULT_FROM_EMAIL=(str, "KIABA <no-reply@example.com>"),
        SERVER_EMAIL=(str, "KIABA Errors <errors@example.com>"),
    )

# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/5.1/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = env("SECRET_KEY")

# SECURITY WARNING: don't run with debug turned on in production!
# Convertir DEBUG correctement (les variables d'environnement sont des strings)
debug_val = env("DEBUG")
if isinstance(debug_val, str):
    DEBUG = debug_val.lower() in ("true", "1", "yes", "on")
else:
    DEBUG = bool(debug_val)

ALLOWED_HOSTS = [h.strip() for h in env("ALLOWED_HOSTS").split(",") if h.strip()]

# Add www version and Render external host automatically
ALLOWED_HOSTS.append("www.ci-kiaba.com")  # Pour accepter www avant redirection

# Add Render external host automatically if present
RENDER_EXTERNAL_URL = os.environ.get("RENDER_EXTERNAL_URL")
if RENDER_EXTERNAL_URL:
    try:
        from urllib.parse import urlparse

        _r = urlparse(RENDER_EXTERNAL_URL)
        if _r.hostname and _r.hostname not in ALLOWED_HOSTS:
            ALLOWED_HOSTS.append(_r.hostname)
    except Exception:
        pass

# Application definition

INSTALLED_APPS = [
    # Django core
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
    "django.contrib.sites",
    "django.contrib.sitemaps",
    "django.contrib.postgres",
    # Third-party
    "rest_framework",
    "django_htmx",
    "corsheaders",
    "imagekit",
    "storages",
    "allauth",
    "allauth.account",
    # Local apps
    "accounts.apps.AccountsConfig",
    "ads",
    "core",
    "moderation",
    "seo",
]

MIDDLEWARE = [
    "django.middleware.security.SecurityMiddleware",
    "whitenoise.middleware.WhiteNoiseMiddleware",
    "core.middleware.RedirectMiddleware",  # Redirections HTTP->HTTPS et www->non-www
    "corsheaders.middleware.CorsMiddleware",
    "django.contrib.sessions.middleware.SessionMiddleware",
    "django.middleware.common.CommonMiddleware",
    "django.middleware.csrf.CsrfViewMiddleware",
    "django.contrib.auth.middleware.AuthenticationMiddleware",
    "allauth.account.middleware.AccountMiddleware",
    "django_htmx.middleware.HtmxMiddleware",
    "django.contrib.messages.middleware.MessageMiddleware",
    "django.middleware.clickjacking.XFrameOptionsMiddleware",
    "core.middleware.AgeGateMiddleware",
]

ROOT_URLCONF = "kiaba.urls"

TEMPLATES = [
    {
        "BACKEND": "django.template.backends.django.DjangoTemplates",
        "DIRS": [BASE_DIR / "templates"],
        "APP_DIRS": True,
        "OPTIONS": {
            "context_processors": [
                "django.template.context_processors.debug",
                "django.template.context_processors.request",
                "django.contrib.auth.context_processors.auth",
                "django.contrib.messages.context_processors.messages",
                "core.context_processors.site_metrics",
            ],
        },
    },
]

WSGI_APPLICATION = "kiaba.wsgi.application"


# Database (PostgreSQL)
# https://docs.djangoproject.com/en/5.1/ref/settings/#databases

if "test" in sys.argv or env("DB_ENGINE") == "sqlite":
    # Utiliser SQLite pour tests/dev rapide
    DATABASES = {
        "default": {
            "ENGINE": "django.db.backends.sqlite3",
            "NAME": BASE_DIR / "db.sqlite3",
        }
    }
else:
    # Configuration PostgreSQL avec SSL pour Render
    postgres_host = env("POSTGRES_HOST", default="")
    is_render_db = "render.com" in postgres_host.lower() or os.environ.get("RENDER_EXTERNAL_URL")

    # Options de connexion de base
    db_options = {
        "connect_timeout": 10,
    }

    if is_render_db:
        # Sur Render, PostgreSQL exige TOUJOURS SSL/TLS pour toutes les connexions
        # Utiliser le host fourni tel quel (Render peut fournir un host avec -a dans le nom)
        # Ne pas modifier le host, utiliser celui fourni par Render
        
        # Render PostgreSQL exige SSL pour toutes les connexions
        # IMPORTANT: Pour psycopg2, sslmode doit √™tre dans OPTIONS
        # Utiliser 'require' qui force SSL
        db_options["sslmode"] = "require"
        # D√©finir aussi les variables d'environnement pour psycopg2
        os.environ["PGSSLMODE"] = "require"
        # Ajouter connect_timeout pour √©viter les timeouts
        db_options["connect_timeout"] = 10
        # Ne pas d√©finir de certificats SSL (utiliser les certificats syst√®me par d√©faut)
        # Cela permet √† psycopg2 d'utiliser les certificats syst√®me

    DATABASES = {
        "default": {
            "ENGINE": "django.db.backends.postgresql",
            "NAME": env("POSTGRES_DB"),
            "USER": env("POSTGRES_USER"),
            "PASSWORD": env("POSTGRES_PASSWORD"),
            "HOST": postgres_host,
            "PORT": env("POSTGRES_PORT"),
            "OPTIONS": db_options,
            "CONN_MAX_AGE": 0,  # D√©sactiver le pooling pour √©viter les probl√®mes de connexion
            "ATOMIC_REQUESTS": True,
        }
    }


# Password validation
# https://docs.djangoproject.com/en/5.1/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        "NAME": "django.contrib.auth.password_validation.UserAttributeSimilarityValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.MinimumLengthValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.CommonPasswordValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.NumericPasswordValidator",
    },
]


# Internationalization
# https://docs.djangoproject.com/en/5.1/topics/i18n/

LANGUAGE_CODE = "fr"
LANGUAGES = [
    ("fr", "Fran√ßais"),
    ("en", "English"),
]

TIME_ZONE = env("TIME_ZONE")

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.1/howto/static-files/

STATIC_URL = env("STATIC_URL")
_static_root = env("STATIC_ROOT")
if not os.path.isabs(_static_root):
    STATIC_ROOT = BASE_DIR / _static_root
else:
    STATIC_ROOT = _static_root
STATICFILES_DIRS = [BASE_DIR / "static"]
STATICFILES_STORAGE = "whitenoise.storage.CompressedManifestStaticFilesStorage"

# WhiteNoise configuration for media files
WHITENOISE_USE_FINDERS = True
WHITENOISE_AUTOREFRESH = True
# Cache static files for 1 year (31536000 seconds)
WHITENOISE_MAX_AGE = 31536000

# Media
MEDIA_URL = env("MEDIA_URL")
_media_root = env("MEDIA_ROOT")
if not os.path.isabs(_media_root):
    MEDIA_ROOT = BASE_DIR / _media_root
else:
    MEDIA_ROOT = _media_root

# Default primary key field type
# https://docs.djangoproject.com/en/5.1/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = "django.db.models.BigAutoField"

# Sites framework
SITE_ID = 1
SITE_URL = env("SITE_URL", default="http://localhost:8000")

# Caches (Forcer le cache local pour √©viter les erreurs Redis)
CACHES = {
    "default": {
        "BACKEND": "django.core.cache.backends.locmem.LocMemCache",
        "LOCATION": "unique-snowflake",
    }
}

# DRF (prepare throttling for rate limiting contact clicks)
REST_FRAMEWORK = {
    "DEFAULT_AUTHENTICATION_CLASSES": [
        "rest_framework.authentication.SessionAuthentication",
    ],
    "DEFAULT_THROTTLE_CLASSES": [
        "rest_framework.throttling.AnonRateThrottle",
        "rest_framework.throttling.UserRateThrottle",
    ],
    "DEFAULT_THROTTLE_RATES": {
        "anon": "100/minute",
        "user": "300/minute",
    },
}

# CSRF / Security
_base_csrf = [
    "http://localhost:8000",
    "http://127.0.0.1:8000",
    "http://localhost:8001",
    "http://127.0.0.1:8001",
    "http://localhost:8002",
    "http://127.0.0.1:8002",
]
_dynamic_csrf = []
try:
    from urllib.parse import urlparse as _urlparse

    if SITE_URL:
        _s = _urlparse(SITE_URL)
        if _s.scheme and _s.netloc:
            _dynamic_csrf.append(f"{_s.scheme}://{_s.netloc}")
    if RENDER_EXTERNAL_URL:
        _r = _urlparse(RENDER_EXTERNAL_URL)
        if _r.scheme and _r.netloc:
            _dynamic_csrf.append(f"{_r.scheme}://{_r.netloc}")
except Exception:
    pass
CSRF_TRUSTED_ORIGINS = _base_csrf + _dynamic_csrf
SECURE_CONTENT_TYPE_NOSNIFF = True
SECURE_BROWSER_XSS_FILTER = True
X_FRAME_OPTIONS = "DENY"
SESSION_COOKIE_SECURE = False if DEBUG else True
CSRF_COOKIE_SECURE = False if DEBUG else True
SECURE_HSTS_SECONDS = 0 if DEBUG else 3600
SECURE_HSTS_INCLUDE_SUBDOMAINS = not DEBUG
SECURE_HSTS_PRELOAD = not DEBUG
SECURE_PROXY_SSL_HEADER = ("HTTP_X_FORWARDED_PROTO", "https")

# CORS (if needed for future API)
CORS_ALLOW_ALL_ORIGINS = DEBUG

# Email - Configuration de base
# IMPORTANT: En production (sur Render), toujours utiliser SMTP
# V√©rifier si on est sur Render (pr√©sence de RENDER_EXTERNAL_URL)
IS_RENDER = bool(os.environ.get("RENDER_EXTERNAL_URL"))

if DEBUG and not IS_RENDER:
    # D√©veloppement local uniquement
    EMAIL_BACKEND = env("EMAIL_BACKEND", default="django.core.mail.backends.console.EmailBackend")
else:
    # PRODUCTION (Render ou DEBUG=False) : Forcer SMTP
    EMAIL_BACKEND = "django.core.mail.backends.smtp.EmailBackend"

EMAIL_HOST = env("EMAIL_HOST", default="localhost")
EMAIL_PORT = env.int("EMAIL_PORT", default=25)
EMAIL_USE_SSL = env("EMAIL_USE_SSL", default=False)
EMAIL_USE_TLS = env("EMAIL_USE_TLS", default=False)
EMAIL_HOST_USER = env("EMAIL_HOST_USER", default="")
EMAIL_HOST_PASSWORD = env("EMAIL_HOST_PASSWORD", default="")
DEFAULT_FROM_EMAIL = env("DEFAULT_FROM_EMAIL", default="KIABA <no-reply@example.com>")
SERVER_EMAIL = env("SERVER_EMAIL", default="KIABA Errors <errors@example.com>")
EMAIL_TIMEOUT = env.int("EMAIL_TIMEOUT", default=10)

# Production email settings - Override avec les variables d'environnement
# IMPORTANT: Toujours forcer SMTP en production, m√™me si DEBUG est True par erreur
if not DEBUG or os.environ.get("FORCE_SMTP", "False").lower() in ("true", "1"):
    # Forcer SMTP en production
    EMAIL_BACKEND = "django.core.mail.backends.smtp.EmailBackend"

    # Lire les variables d'environnement et convertir correctement
    if env("EMAIL_HOST"):
        EMAIL_HOST = env("EMAIL_HOST")

    if env("EMAIL_PORT"):
        port_val = env("EMAIL_PORT")
        try:
            EMAIL_PORT = int(port_val) if isinstance(port_val, str) else port_val
        except (ValueError, TypeError):
            EMAIL_PORT = 465  # Default SSL port

    if env("EMAIL_USE_TLS"):
        tls_val = env("EMAIL_USE_TLS")
        EMAIL_USE_TLS = (
            tls_val in (True, "True", "true", "1", 1) if isinstance(tls_val, str) else bool(tls_val)
        )
    else:
        EMAIL_USE_TLS = False

    if env("EMAIL_USE_SSL"):
        ssl_val = env("EMAIL_USE_SSL")
        EMAIL_USE_SSL = (
            ssl_val in (True, "True", "true", "1", 1) if isinstance(ssl_val, str) else bool(ssl_val)
        )
    else:
        EMAIL_USE_SSL = False

    if env("EMAIL_HOST_USER"):
        EMAIL_HOST_USER = env("EMAIL_HOST_USER")

    if env("EMAIL_HOST_PASSWORD"):
        EMAIL_HOST_PASSWORD = env("EMAIL_HOST_PASSWORD")

    if env("DEFAULT_FROM_EMAIL"):
        DEFAULT_FROM_EMAIL = env("DEFAULT_FROM_EMAIL")

    if env("SERVER_EMAIL"):
        SERVER_EMAIL = env("SERVER_EMAIL")

    # Logging pour debug au d√©marrage
    import logging

    email_logger = logging.getLogger("django.mail")
    email_logger.setLevel(logging.INFO)
    email_logger.info(
        f"üìß EMAIL CONFIG: BACKEND={EMAIL_BACKEND}, HOST={EMAIL_HOST}, PORT={EMAIL_PORT}, SSL={EMAIL_USE_SSL}, TLS={EMAIL_USE_TLS}, USER={EMAIL_HOST_USER[:3] if EMAIL_HOST_USER else 'None'}***, DEBUG={DEBUG}"
    )

    # V√©rifier que le backend n'est pas console
    if "console" in EMAIL_BACKEND.lower():
        email_logger.error("‚ö†Ô∏è ATTENTION: Le backend console est utilis√© au lieu de SMTP!")
        EMAIL_BACKEND = "django.core.mail.backends.smtp.EmailBackend"
        email_logger.info(f"‚úÖ Backend forc√© √† SMTP: {EMAIL_BACKEND}")

# Configuration avanc√©e pour les emails
# S'assurer que le nom "KIABA" appara√Æt dans les emails
if not DEFAULT_FROM_EMAIL.startswith("KIABA"):
    # Si l'email ne contient pas d√©j√† le nom, on le formate
    if "<" not in DEFAULT_FROM_EMAIL:
        DEFAULT_FROM_EMAIL = f"KIABA <{DEFAULT_FROM_EMAIL}>"

# Configuration SMTP avanc√©e pour meilleure d√©livrabilit√© et √©viter les spams
EMAIL_USE_LOCALTIME = True
EMAIL_SUBJECT_PREFIX = "[KIABA] "

# Configuration pour am√©liorer la d√©livrabilit√© et √©viter les spams
# Headers personnalis√©s pour am√©liorer la r√©putation
EMAIL_HEADERS = {
    "X-Mailer": "KIABA Platform",
    "X-Priority": "3",
    "X-MSMail-Priority": "Normal",
    "List-Unsubscribe": "<mailto:support@ci-kiaba.com>",
    "List-Unsubscribe-Post": "List-Unsubscribe=One-Click",
}

# Configuration pour √©viter les spams
# S'assurer que les emails sont bien format√©s
EMAIL_USE_8BIT = False
EMAIL_CHARSET = "utf-8"

# Storage
DEFAULT_FILE_STORAGE = env("DEFAULT_FILE_STORAGE")

# Google Analytics
GA_MEASUREMENT_ID = env("GA_MEASUREMENT_ID", default=None)

# Google AdSense
ADSENSE_PUBLISHER_ID = env("ADSENSE_PUBLISHER_ID", default=None)  # Format: ca-pub-XXXXXXXXXX
ADSENSE_ENABLED = env("ADSENSE_ENABLED", default="False").lower() in ("true", "1", "yes")

# Celery (broker/backend via Redis ou base de donn√©es)
REDIS_URL = env("REDIS_URL", default=None)
if REDIS_URL and REDIS_URL.strip():
    CELERY_BROKER_URL = REDIS_URL
    CELERY_RESULT_BACKEND = REDIS_URL
    CELERY_TASK_ALWAYS_EAGER = False  # Utiliser Celery avec Redis
else:
    # Fallback vers base de donn√©es pour le d√©veloppement
    CELERY_BROKER_URL = "memory://"
    CELERY_RESULT_BACKEND = "cache+memory://"
    # En production sans Redis, ex√©cuter les t√¢ches Celery en mode synchrone
    CELERY_TASK_ALWAYS_EAGER = True  # Mode synchrone si pas de Redis

CELERY_TIMEZONE = TIME_ZONE
CELERY_TASK_ACCEPT_CONTENT = ["json"]
CELERY_TASK_SERIALIZER = "json"
CELERY_RESULT_SERIALIZER = "json"
CELERY_BEAT_SCHEDULE = {
    "expire-ads-daily": {
        "task": "ads.tasks.expire_ads",
        "schedule": 60 * 60 * 24,  # quotidien
    }
}

# Sitemaps
SITEMAP_PROTOCOL = "https"

# Authentication backends (allauth + Django)
AUTHENTICATION_BACKENDS = (
    "django.contrib.auth.backends.ModelBackend",
    "allauth.account.auth_backends.AuthenticationBackend",
)

# allauth basic settings (we'll restrict provider signups later via adapter/forms)
ACCOUNT_AUTHENTICATION_METHOD = "username_email"
ACCOUNT_EMAIL_REQUIRED = True
ACCOUNT_EMAIL_VERIFICATION = "mandatory"  # Obligatoire pour valider les comptes
LOGIN_REDIRECT_URL = "/dashboard"
LOGIN_URL = "/auth/login/"
ACCOUNT_LOGOUT_REDIRECT_URL = "/"
LOGOUT_REDIRECT_URL = "/"
ACCOUNT_EMAIL_CONFIRMATION_AUTO_LOGIN = True
ACCOUNT_EMAIL_CONFIRMATION_ANONYMOUS_REDIRECT_URL = "/auth/login/"
ACCOUNT_EMAIL_CONFIRMATION_AUTHENTICATED_REDIRECT_URL = "/dashboard/"

# D√©sactiver le rate limiting d'allauth pour √©viter les erreurs Redis
ACCOUNT_RATE_LIMITS = {}
ACCOUNT_LOGIN_ATTEMPTS_LIMIT = None
ACCOUNT_LOGIN_ATTEMPTS_TIMEOUT = None
ACCOUNT_PASSWORD_RESET_ATTEMPTS_LIMIT = None
ACCOUNT_PASSWORD_RESET_ATTEMPTS_TIMEOUT = None

# D√©sactiver la page de confirmation de d√©connexion
ACCOUNT_LOGOUT_ON_GET = True

# Utiliser l'adaptateur personnalis√©
ACCOUNT_ADAPTER = "accounts.adapters.NoRateLimitAccountAdapter"

# Utiliser les formulaires personnalis√©s
ACCOUNT_FORMS = {
    "login": "accounts.forms.CustomLoginForm",
    "signup": "accounts.forms.CustomSignupForm",
}

# Custom user model
AUTH_USER_MODEL = "accounts.CustomUser"
